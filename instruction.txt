Отлично. Я подготовлю подробную инструкцию по установке, запуску, разработке, резервному копированию и отладке кастомного ERPNext-приложения ferum\_customs с учетом использования Docker, GitHub Actions, интеграций с Google Drive, Sheets, Telegram Bot и кастомных модулей (ServiceRequest, ServiceProject и др.). Документ будет охватывать как dev-среду, так и production.

Я скоро пришлю черновик для вашего ознакомления.


# Ferum Customizations – Инструкция по установке и настройке

**Ferum Customizations** – это кастомное ERPNext-приложение на базе Frappe Framework, предназначенное для автоматизации сервисных заявок и связанных бизнес-процессов. Данное руководство подробно описывает шаги по установке, настройке и эксплуатации приложения, включая требования к окружению, развёртывание (в том числе в Docker), резервное копирование, настройку среды разработки и лучшие практики (CI/CD, фикстуры, безопасность, мониторинг).

## 1. Предварительные требования

Перед началом убедитесь, что у вас установлено и настроено следующее:

* **Docker** – платформа контейнеризации для развёртывания приложения (см. \[инструкцию по установке Docker Engine]).
* **Docker Compose** – инструмент оркестрации контейнеров (см. \[инструкцию по установке Docker Compose]).
* **Git и GitHub** – доступ к исходному коду приложения. Понадобится Git для клонирования репозитория `ferum_customs` (GitHub-аккаунт для доступа к приватному репозиторию, если требуется).
* **Visual Studio Code** с расширением **Dev Containers** – рекомендуется для удобной работы в дев-окружении (Dev Containers позволят открыть проект в контейнере с уже настроенным окружением).
* **Frappe/ERPNext 15** – само приложение рассчитано на ERPNext v15, поэтому убедитесь, что используете совместимые версии образов/репозиториев Frappe и ERPNext.

> **Примечание:** Инструкции ориентированы на использование Docker-контейнеров для простоты развертывания. Возможна установка и без Docker (на “bare-metal” сервере с помощью Frappe Bench), однако Docker значительно упрощает процесс и обеспечивает портативность среды.

## 2. Начальная настройка среды

**Шаг 1. Клонирование репозитория.**  Склонируйте репозиторий с кодом Ferum Customizations на вашу машину (или сервер):

```bash
git clone https://github.com/your-org/ferum_customs.git
cd ferum_customs
```

*(Замените `your-org` и URL на актуальный адрес репозитория. Если репозиторий приватный, потребуется доступ по токену или SSH – см. раздел 8.1 о CI/CD и приватных репозиториях.)*

**Шаг 2. Конфигурация `.env`.** В корне проекта должен быть пример файла окружения `.env.example`. Скопируйте его в `.env` и отредактируйте под вашу конфигурацию. Ниже приведён пример основных переменных (нужно заменить значения на свои):

```dotenv
# версионирование образов
BENCH_TAG=v5.25.4            # тег Docker-образа bench (соответствует версии Frappe Bench)
ERP_VERSION=version-15       # ветка ERPNext/Frappe (версии 15)

# параметры нового сайта
SITE_NAME=erp.example.com    # имя (домен) ERPNext-сайта
ADMIN_PASSWORD=SuperSecret   # пароль администратора ERPNext

# база данных (пример для PostgreSQL)
DB_TYPE=postgres
POSTGRES_HOST=postgres
POSTGRES_DB=site1
POSTGRES_USER=site1
POSTGRES_PASSWORD=strongpass

# Redis
REDIS_PASSWORD=change_me

# репозиторий кастомного приложения
FERUM_CUSTOMS_REPO=https://github.com/your-org/ferum_customs.git
FERUM_CUSTOMS_BRANCH=main

# интеграция с Google Drive (для хранения вложений)
GOOGLE_DRIVE_SERVICE_ACCOUNT_KEY_FILENAME=google_drive_service_account.json
GOOGLE_DRIVE_FOLDER_ID=your_google_drive_folder_id

# внутренний JWT-токен (для интеграции Frappe ↔ FastAPI)
FASTAPI_INTERNAL_JWT_TOKEN=your_fastapi_internal_jwt_token
```

*Пример файла `.env` основан на конфигурации Ferum Customizations. Не храните этот файл в Git-репозитории, чтобы не раскрывать пароли и ключи.*

Расшифровка ключевых переменных:

* **BENCH\_TAG, ERP\_VERSION** – указывают, какой Docker-образ Frappe Bench использовать и ветку ERPNext. Убедитесь, что версия Frappe/ERPNext соответствует кастомному коду.
* **SITE\_NAME** – доменное имя вашего ERPNext-сайта. В режиме разработки можно указать что-то вроде `site1.localhost` или `localhost` (Docker перенаправит на него порт). В production – реальный домен (например, `erp.ferumrus.ru`).
* **ADMIN\_PASSWORD** – первоначальный пароль для пользователя Administrator ERPNext (после установки его можно изменить).
* **DB\_TYPE** и блок `POSTGRES_...` – тип и параметры СУБД. В примере используется PostgreSQL (рекомендуется для ERPNext v15), но можно использовать и MariaDB (укажите `DB_TYPE=mariadb` и соответствующие переменные для MariaDB). *Важно:* Параметры БД должны совпадать с настройками самого контейнера БД (см. ниже).
* **REDIS\_PASSWORD** – пароль для Redis (используется для кэша и очередей Frappe).
* **FERUM\_CUSTOMS\_REPO, FERUM\_CUSTOMS\_BRANCH** – адрес репозитория и ветки с кастомным приложением. Если репозиторий приватный, можно указать токен доступа (см. раздел 4.4 о способах указать приватный репозиторий).
* **GOOGLE\_DRIVE\*** – настройки интеграции с Google Drive для хранения файлов (необязательно на этапе установки, но предусмотрено архитектурой). `GOOGLE_DRIVE_SERVICE_ACCOUNT_KEY_FILENAME` – имя JSON-файла с ключом сервисного аккаунта Google (файл нужно поместить в `sites/<SITE_NAME>/private/keys/`). `GOOGLE_DRIVE_FOLDER_ID` – ID папки в Google Drive, куда будут сохраняться вложения.
* **FASTAPI\_INTERNAL\_JWT\_TOKEN** – секретный токен для внутреннего обмена между ERPNext и FastAPI-бэкендом (например, для webhook’ов или бота). Его нужно сгенерировать случайным образом и держать в секрете.

**Шаг 3. Структура проекта.** После клонирования и настройки `.env` убедитесь, что структура каталогов выглядит следующим образом:

* **`docker-compose.yml`** – основной Docker Compose файл (мы создадим/проверим его на следующем шаге).
* **`docker/`** – (если присутствует) дополнительные docker-compose файлы или ресурсы для Docker.
* **`ferum_customs/`** – директория кастомного приложения Frappe (Python-пакет с DocType, Hooks и т.д.).
* **`backend/`** – директория внешнего backend-приложения (FastAPI) и ботов. Здесь находятся Python-модули FastAPI (`routers/`, `auth.py`, конфиги) и, например, Telegram-бот (`bot/telegram_bot.py`).
* **`docs/`** – документация (например, техническая спецификация, design docs и т.п.).
* **`.devcontainer/`** – конфигурация для VSCode Dev Containers (для удобства разработки).
* **`scripts/`** – (если есть) вспомогательные скрипты, например, для быстрого развёртывания на сервере без Docker.
* Другие служебные файлы: `requirements.txt`, `Procfile`, конфиги CI и пр.

Убедитесь, что все необходимые файлы присутствуют. Особое внимание файлу `docker-compose.yml` – он может быть уже в репозитории, либо его нужно создать вручную (см. следующий раздел).

## 3. Быстрый старт в среде разработки (Docker Compose)

Для быстрого запуска приложения в режиме разработки используется Docker Compose. Предполагается, что вы будете запускать всё локально (на вашей машине) или в песочнице Docker. Все необходимые образы (ERPNext, БД, Redis) загрузятся автоматически.

**Шаг 1: docker-compose.yml для разработки.** Используйте упрощённый Compose-файл, достаточный для запуска одного контейнера Bench (ERPNext) и сопутствующих сервисов (Postgres, Redis). Ниже приведён базовый пример `docker-compose.yml`:

```yaml
services:
  backend:
    image: frappe/bench:${BENCH_TAG}
    container_name: frappe
    env_file: .env
    working_dir: /home/frappe/frappe-bench
    ports:
      - "8000:8000"              # проброс порта ERPNext (и FastAPI) наружу
    depends_on:
      - postgres
      - redis
    volumes:
      - bench-vol:/home/frappe/frappe-bench
    command: >
      bash -lc "bench start"     # запуск процессов Frappe (web, worker и др.)

  postgres:
    image: postgres:13
    env_file: .env
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7
    command: ["redis-server", "--requirepass", "${REDIS_PASSWORD}"]

volumes:
  bench-vol:
  pgdata:
```

В этом файле определены три контейнера: `backend` (основной контейнер с Frappe/ERPNext), `postgres` (СУБД PostgreSQL) и `redis` (кэш/очередь). Обратите внимание:

* Используется официальный образ `frappe/bench` с тегом из переменной окружения `BENCH_TAG`. Этот образ содержит необходимые компоненты для работы Frappe/ERPNext.
* Директория Bench внутри контейнера маунтится на named volume `bench-vol`, чтобы сохранять установленные приложения и данные между перезапусками контейнера. (В разработке вы можете заменить volume на маунтинг локальной папки для быстрых итераций кода – см. `docker-compose.override.yml` ниже).
* Контейнер `backend` автоматически запускает `bench start`, который внутри запускает сервер ERPNext (Gunicorn) на порт 8000, а также фоновые процессы (workers, scheduler). Порт 8000 пробрасывается на хост для доступа.
* Контейнеры `postgres` и `redis` используют стандартные образы. Пароль и имя БД берутся из `.env`. Данные БД сохраняются на volume `pgdata`. Redis запускается с паролем (тоже из `.env`).

Если файл `docker-compose.yml` уже предоставлен в репозитории, проверьте его содержание и скорректируйте при необходимости под вашу среду (например, версию образа, порты). Для development-режима этого достаточно. В production-окружении, как правило, добавляются отдельные сервисы для воркеров и веб-сервера Nginx – об этом в разделе 4.

**Шаг 2: одноразовый сервис установки (setup).** Чтобы автоматизировать первичную установку приложения (создание сайта, скачивание и установка кастомного приложения, выполнение миграций), проект Ferum Customizations использует специальный сервис `setup` в Docker Compose. Добавьте его в `docker-compose.yml` (он выполнится и завершится автоматически):

```yaml
  setup:
    image: frappe/bench:${BENCH_TAG}
    container_name: frappe-setup
    env_file: .env
    working_dir: /home/frappe/frappe-bench
    depends_on:
      - backend
    volumes:
      - bench-vol:/home/frappe/frappe-bench
    entrypoint: [ "bash", "-lc" ]
    command: |
      '
      set -e
      # 1) Создать сайт (если не существует)
      if ! bench --site ${SITE_NAME} whoami >/dev/null 2>&1; then
        echo "[setup] Creating site ${SITE_NAME}..."
        bench new-site ${SITE_NAME} \
          --db-type ${DB_TYPE} \
          --db-host ${POSTGRES_HOST} \
          --db-name ${POSTGRES_DB} \
          --db-user ${POSTGRES_USER} \
          --db-password ${POSTGRES_PASSWORD} \
          --admin-password ${ADMIN_PASSWORD} \
          --no-mariadb-socket
      else
        echo "[setup] Site ${SITE_NAME} already exists."
      fi

      # 2) Получить приложение (если не скачано)
      if [ ! -d apps/ferum_customs ]; then
        echo "[setup] bench get-app ferum_customs..."
        bench get-app ferum_customs ${FERUM_CUSTOMS_REPO} --branch ${FERUM_CUSTOMS_BRANCH}
      else
        echo "[setup] App ferum_customs already present. Updating..."
        cd apps/ferum_customs && git fetch --all && git checkout ${FERUM_CUSTOMS_BRANCH} && git pull || true
        cd - >/dev/null
      fi

      # 3) Установить приложение на сайт (если не установлено)
      if ! bench --site ${SITE_NAME} list-apps | grep -q "^ferum_customs$"; then
        echo "[setup] Install app on site..."
        bench --site ${SITE_NAME} install-app ferum_customs
      else
        echo "[setup] App already installed on ${SITE_NAME}."
      fi

      # 4) Применить миграции
      bench --site ${SITE_NAME} migrate

      echo "[setup] Done."
      '
    restart: "no"
```

Этот сервис выполнит следующие действия при первом запуске: создаст новый сайт ERPNext с именем `SITE_NAME` (используя указанные в `.env` параметры базы и пароль администратора), затем клонирует репозиторий кастомного приложения в папку `apps/ferum_customs` (если ещё не склонирован) и установит это приложение на сайт, после чего выполнит миграции базы данных. Благодаря общему тому же volume `bench-vol`, все изменения (созданный сайт, скачанное приложение) сохранятся и будут видны основному `backend`-контейнеру.

**Шаг 3: запуск приложения (dev).** Теперь можно запустить стек Docker Compose. В режиме разработки удобно запускать сервисы поочерёдно:

```bash
docker compose up -d postgres redis    # запустить БД и Redis
docker compose up -d backend          # запустить Bench (ERPNext)
docker compose run --rm setup         # выполнить одноразовую настройку (создание сайта, установка приложения)
# После завершения setup, при обычной работе, достаточно запускать:
docker compose up -d                  # поднимает все сервисы (backend, postgres, redis)
```

После успешного выполнения этих команд ERPNext-сайт с вашим приложением будет запущен. Логи можно посмотреть командой `docker compose logs -f backend` (или через `docker compose logs setup` для просмотра вывода шага установки).

**Шаг 4: проверка доступа.** Откройте в браузере адрес [http://localhost:8000](http://localhost:8000) – должна загрузиться страница логина ERPNext. Войдите под пользователем **Administrator** с паролем `ADMIN_PASSWORD`, указанным в `.env`. Вы попадёте на рабочий стол ERPNext.

Проверить работу кастомного FastAPI-бэкэнда (если он встроен) можно по эндпоинту здоровья: [http://localhost:8000/api/v1/health](http://localhost:8000/api/v1/health) – он должен вернуть положительный ответ (например, `{"status":"OK"}`). Дело в том, что FastAPI-приложение интегрировано в тот же процесс (через Frappe ASGI) и доступно по префиксу `/api/v1`.

> **Совет:** В development-режиме для быстрого тестирования можно использовать онлайн-песочницу **Play With Docker (PWD)**. На сайте [labs.play-with-docker.com](https://labs.play-with-docker.com/) вы сможете запустить временную виртуальную машину с Docker прямо в браузере. Склонируйте туда репозиторий, сконфигурируйте `.env` и выполните описанные выше команды `docker compose up` – это позволит опробовать Ferum Customizations даже без локальной установки Docker.

## 4. Развертывание в production

Для production-среды требуются некоторые дополнительные шаги и более продуманная конфигурация Docker Compose. Здесь мы рассмотрим генерацию конфигурации с override-файлами, создание сайта (если делается вручную), обновление приложения, а также сборку собственного Docker-образа с включённым кастомным приложением.

### 4.1. Генерация docker-compose.yml (production) и overrides

В продакшене обычно используют Compose-файл, похожий на dev-вариант, но с дополнительными сервисами и настройками:

* **Gunicorn workers:** В production-настройке ERPNext рекомендуется запускать отдельные контейнеры/процессы для воркеров (очередей) и планировщика. Например, можно добавить сервисы `queue-default`, `queue-short`, `queue-long`, `scheduler` на основе того же образа, но запускающие `bench worker` с разными параметрами. В dev-режиме `bench start` запускает их в одном контейнере, но для надёжности под нагрузкой их выносят отдельно.
* **Nginx:** В продакшене для обработки HTTP(S) запросов, статики и терминирования TLS обычно ставят Nginx. Можно либо запускать его отдельно на хосте, либо в Docker Compose добавить сервис `nginx` с образом `frappe/nginx` (настроив монтирование сгенерированного конфигурационного файла и сертификатов). Nginx будет проксировать порт 80/443 к backend (порт 8000) и отдавать статические файлы из `sites/assets`. В официальном Frappe Docker есть готовые конфиги для Nginx.
* **Override для dev:** Убедитесь, что dev-специфичные настройки не попадают в production. Например, если у вас есть `docker-compose.override.yml` для разработки (монтирует локальные файлы в контейнер, включает отладочные опции), **не** используйте его в production. Запуск `docker-compose` по умолчанию читает оба файла (основной и override); в продакшене запускайте только основной файл, либо используйте отдельный override для production. В репозитории Ferum может быть пример override-файла для разработки: он монтирует исходники приложения и папку `sites` в контейнер (только для удобства разработки). В prod эти монтирования не нужны – код будет либо включён в образ, либо загружен через bench.

**Пример:** Вы можете иметь два файла – `docker-compose.prod.yml` и `docker-compose.dev.yml`, либо один `docker-compose.yml` + `docker-compose.override.yml`. В продакшене запускайте `docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d`, а в dev – `docker compose up -d` (который автоматически подхватит override).

Убедитесь, что в production-конфигурации заданы корректные параметры: переменная `SITE_NAME` должна соответствовать реальному домену, на сервере открыт нужный порт, и настроен доступ к SMTP (если ERPNext будет слать почту) и др. Настройки HTTPS (TLS) обычно делаются на уровне Nginx – позаботьтесь о получении сертификатов (например, через Let’s Encrypt/Certbot) и их обновлении.

### 4.2. Создание сайта через bench вручную

Если вы не используете автоматический сервис `setup` (или устанавливаете приложение на существующий bench), нужно вручную создать новый сайт ERPNext и установить приложение. Это делается с помощью команд bench внутри контейнера (либо на хосте, если установлен Frappe Bench):

1. **Создание нового сайта:**
   Внутри Docker-контейнера bench (или на хосте, где инициализирован bench) выполните:

   ```bash
   bench new-site <SITE_NAME> \
       --db-type ${DB_TYPE} \
       --db-host ${DB_HOST} \
       --db-name ${POSTGRES_DB} \
       --db-user ${POSTGRES_USER} \
       --db-password ${POSTGRES_PASSWORD} \
       --admin-password ${ADMIN_PASSWORD}
   ```

   Замените параметры в соответствии с вашей БД. Для PostgreSQL укажите `--db-type postgres` и креденшалы, для MariaDB можно не указывать (`bench` возьмёт соединение по умолчанию). Флаг `--no-mariadb-socket` полезен, если bench пытается подключиться через сокет, а у вас СУБД в контейнере/по сети. После выполнения команды будет создан новый сайт (в папке `sites/<SITE_NAME>`), и инициализирована база данных.
2. **Установка кастомного приложения:**
   Скачайте исходники приложения в bench (если не склонированы):

   ```bash
   bench get-app ferum_customs <REPO_URL> --branch <BRANCH>
   ```

   Либо скопируйте папку приложения `ferum_customs` в `apps/` (например, если вы разворачиваете из zip-архива релиза). Затем установите приложение на созданный сайт:

   ```bash
   bench --site <SITE_NAME> install-app ferum_customs
   ```

   После этого кастомные DocType и другие данные приложения будут добавлены на сайт.
3. **Миграции:**
   Выполните миграции, чтобы применить изменения модели данных:

   ```bash
   bench --site <SITE_NAME> migrate
   ```

   Bench применит все отложенные патчи и миграции, обеспечивая актуальное состояние БД.

Эти шаги эквивалентны тому, что делает сервис `setup` автоматически. В production-сценарии вы можете предпочесть ручной контроль: например, сначала обновить код приложения, потом вручную запустить миграции в контролируемом порядке.

> **Замечание:** Если вы используете PostgreSQL, убедитесь, что в `common_site_config.json` вашего bench (или переменные окружения) прописаны правильные настройки подключения. Для мультисайтового режима важно, чтобы каждый сайт имел свои креденшалы. Обычно `bench new-site` сам прописывает их в `site_config.json` сайта.

### 4.3. Обновление приложения: новые образы и миграции

Развёрнутое приложение нужно уметь обновлять (деплой новых версий). Общий процесс такой:

1. **Обновление кода приложения:** если вы **не** используете собственный образ, а подтягиваете код из GitHub при каждом запуске (как в методе с сервисом `setup`), то достаточно обновить репозиторий и запустить миграции. В Docker Compose методе можно просто перезапустить `setup` на уже работающем инстансе:

   ```bash
   docker compose run --rm setup
   docker compose restart backend
   ```

   Эта последовательность стянет последние изменения из Git и применит миграции на сайте, затем перезапустит основной контейнер. Ваши пользователи получат обновление с минимальным даунтаймом.
2. **Обновление образов Frappe/ERPNext:** периодически выходят обновления самого Frappe/ERPNext. Чтобы обновить версию платформы, измените переменную `BENCH_TAG` (например, на более свежий тег) и `ERP_VERSION` (если переходите на новую ветку, например, с version-15 на version-16). После этого выполните:

   ```bash
   docker compose pull backend  # скачать обновлённый образ bench
   docker compose up -d backend # или перезапустить с новым образом
   docker compose run --rm setup && docker compose restart backend
   ```

   Перезапуск `setup` после обновления образа гарантирует, что выполнится `bench migrate` для обновления БД до новой версии. **Важно:** перед обновлением ERPNext рекомендуется прочитать release notes – возможно, потребуются доп. действия.
3. **Migrating**: Всегда после обновления кода или образов запускайте `bench migrate`. Если вы обновляете только код приложения (не меняя версию Frappe), можно выполнить миграцию и сборку ассетов без перезапуска всего контейнера:

   ```bash
   docker compose exec -u frappe backend bash -lc "bench build && bench --site ${SITE_NAME} migrate"
   ```

   Это сгенерирует новые бандлы JS/CSS (если есть) и применит миграции на базе данных.

Следите за логами во время миграций. Если что-то пошло не так, лучше откатиться (например, вернув старый образ или код из бэкапа) и разобраться, чем пытаться продолжить на повреждённой миграции.

### 4.4. Собственный Docker-образ с кастомными приложениями

Вместо того чтобы клонировать кастомное приложение при каждом деплое (или хранить его на volume), можно собрать *свой Docker-образ* ERPNext, в который уже включено приложение `ferum_customs`. Такой подход облегчит деплой (весь код в одном образе) и позволит использовать CI/CD для сборки. Шаги для этого:

1. **Создайте `apps.json`.** В корне проекта (или специальной папке, напр. `resources/`) создайте файл `apps.json` со списком приложений, которые должны быть установлены в образе. Формат – JSON-массив объектов с полями репозиториев. Пример для нашего случая:

   ```json
   [
     {
       "url": "https://github.com/your-org/ferum_customs.git",
       "branch": "main"
     }
   ]
   ```

   Если репозиторий приватный, можно указать URL с токеном, либо настроить SSH-ключи (см. ниже).
2. **Подготовьте Dockerfile (при необходимости).** Обычно можно использовать стандартный Dockerfile из официального репозитория Frappe. Например, в проекте [`frappe_docker`](https://github.com/frappe/frappe_docker) есть `Dockerfile` для custom-образов (иногда называется `Containerfile`). Скопируйте его в свой проект, убедившись, что он поддерживает аргумент `APPS_JSON_BASE64`. Если нужно, скорректируйте – например, добавить копирование вашего `apps.json` внутрь образа.
3. **Соберите образ с аргументом APPS\_JSON\_BASE64.** Главная идея – передать содержимое `apps.json` в Docker сборку. Для этого выполните команды (из директории вашего проекта):

   ```bash
   # (Linux) Экспортируйте base64-представление файла apps.json:
   export APPS_JSON_BASE64=$(base64 -w 0 apps.json)
   # Запустите сборку образа, передав эту переменную как build-arg:
   docker build -t your-registry/erpnext-ferum:latest --build-arg APPS_JSON_BASE64=$APPS_JSON_BASE64 .
   ```

   Где `your-registry/erpnext-ferum:latest` – имя вашего нового образа (можно пушить его в Docker Hub или частный регистр). В Dockerfile аргумент `APPS_JSON_BASE64` должен использоваться при выполнении `bench init` – это указывает bench установить приложения из списка. Альтернативно, можно изменить Dockerfile, чтобы он копировал `apps.json` и запускал `bench init --apps_path /opt/frappe/apps.json` – оба подхода эквивалентны.
4. **Используйте свой образ в Compose.** После сборки измените `docker-compose.yml`: вместо `image: frappe/bench:${BENCH_TAG}` укажите `image: your-registry/erpnext-ferum:latest` (и уберите `FERUM_CUSTOMS_REPO` из `.env`, так как код уже внутри). Перезапустите контейнеры – приложение будет сразу доступно без шага `get-app`. Обновление приложения в этом случае сводится к новой сборке образа и обновлению контейнеров (что хорошо автоматизируется через CI/CD).

> **SSH vs Token:** Если не хотите хранить токен в `apps.json`, можно настроить деплой-ключ SSH. В таком случае, добавьте файлы ключа в контекст сборки и настройте Dockerfile (или `docker-compose.yml`) использовать `GIT_SSH_COMMAND`. Например, монтировать внутрь контейнера закрытый ключ и `known_hosts`, и задавать переменную окружения:
>
> ```yaml
> environment:
>   GIT_SSH_COMMAND: "ssh -i /home/frappe/.ssh/id_rsa -o StrictHostKeyChecking=no"
> ```
>
> Затем URL в `apps.json` можно использовать SSH-формат (`git@github.com:your-org/ferum_customs.git`).

Сборка собственного образа добавляет этап в деплой, но даёт больше контроля: вы можете тестировать образ перед выкатом, включить в него сразу несколько приложений, а также зафиксировать версию кода (образ выступает версионированным артефактом).

## 5. Резервное копирование и восстановление

Надёжные бэкапы – критический аспект production-внедрения. Ferum Customizations предусматривает хранение файлов на Google Drive, но резервное копирование базы данных тоже необходимо. Рекомендуемый подход – автоматизировать бэкап с отправкой в облачное хранилище (например, AWS S3 или Google Drive) с помощью утилиты **restic**.

**Что копируем?** Основные данные системы – это база данных ERPNext (MariaDB или PostgreSQL) и файлы (вложения). В нашем случае большинство файлов (фото, документы) хранятся на Google Drive посредством интеграции, но на сервере всё равно могут быть файлы (например, приватные файлы или резервные копии конфигов). Поэтому бэкапим:

* SQL-дамп базы данных сайта.
* Директорию `sites/<SITE_NAME>/private/files` (если используются локальные файлы) и `public/files` (если есть).
* Опционально – экспорт данных фикстур (роль, DocType) и конфигурации (site\_config.json), хотя они уже в коде/настройках.

**Настройка restic (S3 пример):**

1. Установите restic на сервер. Создайте S3-бакет (или используйте существующий). Настройте учётные данные AWS (через переменные окружения `AWS_ACCESS_KEY_ID` и `AWS_SECRET_ACCESS_KEY`).
2. Инициализируйте репозиторий restic:

   ```bash
   export RESTIC_REPOSITORY=s3:s3.amazonaws.com/<your-bucket-name>/ferum-backups
   export RESTIC_PASSWORD=<strong_encryption_password>
   restic init   # выполните один раз
   ```

   (RESTIC\_PASSWORD – пароль шифрования резервных копий, храните его в секрете!)
3. Создайте скрипт бэкапа (например, `backup.sh`), который выполняет:

   ```bash
   #!/bin/bash
   TIMESTAMP=$(date +%F_%H%M%S)
   # 1. Создать дамп базы
   docker compose exec -T postgres pg_dump -U ${POSTGRES_USER} ${POSTGRES_DB} > /tmp/${SITE_NAME}-${TIMESTAMP}.sql
   # 2. Сохранить копию site_config (содержит ключи доступа, полезно для восстановления)
   docker compose exec -T backend cat sites/${SITE_NAME}/site_config.json > /tmp/${SITE_NAME}-site_config.json
   # 3. Запустить restic backup
   restic backup /tmp/${SITE_NAME}-${TIMESTAMP}.sql /tmp/${SITE_NAME}-site_config.json
   # (опционально: restic backup /path/to/other/files ...)
   # 4. Удалить локальные временные дампы
   rm /tmp/${SITE_NAME}-${TIMESTAMP}.sql /tmp/${SITE_NAME}-site_config.json
   # 5. (опционально) Причесать старые бэкапы:
   restic forget --keep-daily 7 --keep-weekly 4 --prune
   ```

   Скрипт выше предполагает, что dump выполняется из контейнера postgres (для PostgreSQL) или можно использовать `bench --site <site> backup` для MariaDB. Он сохраняет дамп и конфиг, затем отправляет их в S3 через restic. Команда `forget` удаляет старые резервные копии, оставляя 7 последних дневных и 4 недельных.
4. Настройте cron на выполнение этого скрипта каждый день ночью. Например, добавьте в crontab:
   `0 2 * * * /home/frappe/backup.sh >> /home/frappe/backup.log 2>&1` – будет запускать бэкап каждую ночь в 2:00 и писать лог.

**Google Drive вместо S3:** Если вы предпочитаете хранить бэкапы в Google Drive, один из вариантов – использовать `rclone` вместе с restic. `rclone` умеет работать с Google Drive API. Можно настроить remote-диск в `rclone` и затем RESTIC\_REPOSITORY указывать как `rclone:remote:backup-folder`. Другой подход – полагаться на встроенную интеграцию: согласно технической спецификации, система автоматически загружает резервные файлы базы на защищённую папку Google Drive. Это можно реализовать, например, через `bench backup --with-files` + вызов Google Drive API (скрипт илиIntegration).

**Восстановление:** Документируйте процесс восстановления заранее. Обычно он включает:

* Развёртывание нового сервера с той же версией ERPNext/приложения.
* Развёртывание Docker Compose с теми же переменными.
* Восстановление БД: развернуть чистый сайт (bench new-site), затем импортировать SQL дамп (`bench --site site_name restore /path/to/dump.sql`).
* Восстановление файлов: если использовался Drive, убедиться что интеграция настроена и файлы доступны; если локально – скопировать `private/files` и `public/files` из бэкапа.
* Проверить `site_config.json` – возможно, нужно восстановить строки (например, ключи шифрования, интеграции).

Регулярно проверяйте, что бэкапы успешно создаются и **главное** – могут быть восстановлены. Рекомендуется хотя бы раз в несколько месяцев выполнять тестовое восстановление на staging-сервере, чтобы убедиться, что процесс рабочий и все данные целы.

## 6. Настройка среды разработки

Для комфортной разработки кастомного приложения рекомендуется использовать Dev Containers (VSCode) или локальный bench-стек. Ниже описаны лучшие практики настройки dev-окружения, включая запуск bench, активацию developer mode, настройку сервисов и отладку.

### 6.1. Dev Containers и VS Code

**Dev Container** – это метод, позволяющий открыть проект в готовом контейнере с предустановленным ПО. В репозитории Ferum Customizations есть конфигурация `.devcontainer/devcontainer.json`, которая задаёт базовый контейнер (например, Ubuntu с Docker-in-Docker возможностями)【29†】. Для запуска:

1. Установите расширение **Remote - Containers** (Dev Containers) в VS Code.
2. Откройте папку проекта в VS Code. Нажмите **Reopen in Container** (обычно VSCode сам предложит это при наличии `.devcontainer` конфиг).
3. VSCode построит контейнер согласно настройкам (скачает образ `mcr.microsoft.com/devcontainers/universal` и настроит Docker внутри него). После запуска контейнера вы получите терминал, работающий внутри него.

Внутри Dev Container’a у вас уже будет доступен Docker (благодаря feature "docker-in-docker"【29†】). Это значит, что вы можете запускать команды `docker compose` прямо там, не покидая VSCode. Например, открыть терминал VSCode и повторить шаги запуска из раздела 3:

```bash
docker compose up -d postgres redis
docker compose up -d backend
docker compose run --rm setup
```

Таким образом, Dev Container выступает изолированным окружением для разработки, но сам поднимает нужные контейнеры ERPNext. Плюс в том, что в VSCode вы можете сразу редактировать код, и изменения (при монтировании кода в контейнер) отражаются на работающем приложении.

Dev Container также позволяет устанавливать инструменты для разработки (linters, git) внутри, не засоряя основную систему. Если нужно, вы можете изменить `devcontainer.json`, добавив туда установки Python, bench и прочих зависимостей, но обычно в этом нет нужды, т.к. мы используем Docker Compose для исполнения самого приложения.

### 6.2. Запуск bench в режиме разработки, создание сайта и Developer Mode

Альтернативный подход – развернуть полноценный **Frappe Bench** на локальной машине (или внутри Dev Container) без Docker для приложений. Это полезно для отладки или если нужно использовать интерактивные возможности bench.

Основные шаги повторяют продакшн установку, но с некоторыми упрощениями:

* **Установка зависимостей:** Установите Python 3.10+, Node.js, Redis, Yarn, и сам Bench CLI (`pip install frappe-bench`). Подробности – в официальной документации Frappe. Можно использовать скрипт быстрой установки bench.
* **Инициализация bench:** `bench init --frappe-branch version-15 frappe-bench` – создаст директорию bench с Frappe. Перейдите в неё: `cd frappe-bench`.
* **Создание сайта:** `bench new-site site1.localhost --admin-password YOUR_PASSWORD` (для MariaDB, либо с параметрами для Postgres, если хотите).
* **Установка ERPNext:** `bench get-app erpnext --branch version-15` и `bench --site site1.localhost install-app erpnext` (если ERPNext не шёл в комплекте).
* **Добавление кастомного приложения:** `bench get-app ferum_customs <репозиторий>` (по аналогии с разделом 4.2) и `bench --site site1.localhost install-app ferum_customs`. Теперь ваше приложение подключено.
* **Запуск сервера:** Выполните `bench start` – откроется дев-сервер на [http://localhost:8000](http://localhost:8000).

Далее, **Developer Mode**: этот режим позволяет напрямую создавать/править DocType, Print Format и прочие метаданные через UI и сохранять их сразу в файлы. Чтобы включить developer mode для вашего сайта, выполните:

```bash
bench --site site1.localhost set-config developer_mode 1
bench --site site1.localhost clear-cache
```

Либо вручную в файле `sites/site1.localhost/site_config.json` добавьте `"developer_mode": 1`. После этого перезапустите bench. В Developer Mode система будет при сохранении DocType писать/обновлять JSON-файлы в папке вашего приложения (например, `ferum_customs/ferum_customs/doctype/<YourDocType>/<YourDocType>.json`), а также создавать Python-модели, если выбираете опцию “Custom?” = No. Это удобно для разработки – все изменения мигрируют в код.

**Конфигурация Redis и БД:** Если вы запускаете bench вручную, убедитесь, что в системе запущен Redis-сервер и база данных (MariaDB или Postgres). По умолчанию `bench start` попытается подключиться к Redis на `localhost:6379` и к MariaDB на сокете `/var/run/mysqld/mysqld.sock`. В случае PostgreSQL нужно отредактировать `sites/common_site_config.json`, задав там `db_type`: `"postgres"` и параметры подключения (host, port, etc.).

В Dev Containers можно либо установить и запустить Redis/DB внутри, либо, как вариант, запустить внешние контейнеры Redis/Postgres и настроить bench на их использование. Например, в `site_config.json` указать `"db_host": "host.docker.internal"` (это позволяет bench внутри Dev Container обращаться к БД, запущенной на хосте/в Docker). Однако, проще в разработке использовать MariaDB + Redis локально, установив их через пакетный менеджер, либо полностью полагаться на Docker Compose (как мы делали выше).

**Работа с FastAPI-бэкендом:** В архитектуре Ferum Customizations есть отдельный FastAPI-приложение (папка `backend`). Оно не автоматически управляется bench. Для локальной разработки вы можете запустить его отдельно. Например, установить зависимости:

```bash
pip install -r backend/requirements.txt
```

и запустить FastAPI (например, uvicorn) на другом порту. Однако в текущей реализации FastAPI интегрирован с ERPNext (через общий ASGI-приложение), поэтому, возможно, standalone-запуск не требуются. Для бота (Telegram) – запустите скрипт напрямую:

```bash
python -m backend.bot.telegram_bot
```

(предварительно вставив токен бота и URL в код или в переменные окружения). Этот бот будет подключаться к API вашего ERPNext.

### 6.3. Отладка и debug (VSCode launch.json)

Отладка серверного кода ERPNext/Frappe возможна несколькими способами:

* **Логирование и консоль:** Самый простой – использовать `bench console` (аналог Django shell) для интерактивного выполнения фрагментов кода в контексте сайта. Также можно вставлять временные `print()` или использовать `frappe.logger()` для вывода информации в процессе выполнения. Логи серверных скриптов пишутся в `frappe-bench/logs` и в консоль, запущенную `bench start`.
* **PDB (Python Debugger):** В любом месте кода можно вставить строчку `import pdb; pdb.set_trace()`. Если запущен дев-сервер (в режиме отладки, не мультипроцессовом), выполнение там прервётся и вы получите интерактивную отладочную консоль прямо в терминале, где запущен сервер. В режиме Gunicorn (по умолчанию) это может быть неудобно, поэтому для отладки можно запустить Frappe в режиме **тестового сервера**:

  ```bash
  bench serve --port 8000
  ```

  Эта команда запускает однопоточный сервер (Werkzeug) вместо Gunicorn. Он подходит для отладки – можно подключаться pdb без проблем (не забывайте, что производительность хуже и фоновые задания не запустятся).
* **VSCode Remote Attach:** Если вы работаете через VSCode Dev Container, можно настроить **attach** к Python-процессу. Например, запустить ERPNext с помощью Debugpy. Один из способов: добавить в Procfile команду запуска gunicorn с подключением debugpy, либо запустить `bench serve` как описано и указать флаг `--address 0.0.0.0` (чтобы был доступен вне контейнера). Затем создать `launch.json` в VSCode со следующей конфигурацией (пример):

  ```json
  {
      "name": "Attach to Frappe",
      "type": "python",
      "request": "attach",
      "connect": {
          "host": "localhost",
          "port": 5678
      },
      "pathMappings": [
          {
              "localRoot": "${workspaceFolder}",
              "remoteRoot": "/home/frappe/frappe-bench/apps/ferum_customs"
          }
      ]
  }
  ```

  При запуске отладчика VSCode подключится к порту 5678, ожидающему debugpy. Соответственно, стартуйте сервер так:

  ```bash
  python -m debugpy --listen 0.0.0.0:5678 -m frappe.app
  ```

  (либо настройте bench startup). После подключения сможете ставить breakpoints в коде `ferum_customs` прямо из VSCode.
* **Отладка фоновых задач:** Если нужно дебажить фоновые задачи (Scheduler, Worker), можно запустить воркер вручную через `bench execute` или `bench worker` в отладочном режиме. Например, выполнить конкретный метод:

  ```bash
  bench --site <SITE_NAME> execute ferum_customs.some_module.some_function
  ```

  – так вы вызовете метод напрямую и сможете отследить его выполнение.

Настройка отладки может требовать дополнительного времени, но она окупается при расследовании сложных багов. Всегда держите под рукой документацию Frappe по отладке и сообществные рецепты.

## 7. Устранение неполадок

Ниже перечислены распространённые проблемы при установке/разработке Ferum Customizations и способы их решения:

* **Контейнеры не стартуют / падают:** Проверьте логи соответствующих сервисов: `docker compose logs <service_name>`. Например, `docker compose logs backend` покажет, почему не запускается ERPNext. Частые причины – ошибки миграций, неправильная конфигурация .env, отсутствие доступа к БД.
* **Проблемы с базой данных:** Если при создании сайта вы получаете ошибки соединения, убедитесь, что контейнер БД запущен (`docker compose ps`), а параметры `POSTGRES_HOST`, `POSTGRES_USER`, `POSTGRES_PASSWORD` правильные. Проверьте, не содержит ли пароль спецсимволы, которые могут неправильно интерпретироваться (лучше обрамлять значения в кавычки в .env). Для MariaDB: убедитесь, что в `site_config.json` нет параметра `db_host` (по умолчанию bench использует локальный сокет). Если вы запускаете bench вне Docker, возможно, нужно задать `db_host`: `"127.0.0.1"`.
* **Nginx не раздаёт сайт:** В случае самостоятельной конфигурации Nginx проверьте, сгенерирован ли конфиг: `bench setup nginx` создаёт `/etc/nginx/conf.d/frappe-bench.conf` (или аналог) с настройками. Убедитесь, что DNS вашего домена указывает на сервер, и сертификаты SSL корректно установлены. Если Nginx в Docker – посмотрите его логи. Также, проверьте, что параметр `Host_name` вашего сайта (в ERPNext) совпадает с доменом – иначе ERPNext может не обслуживать запросы (ERPNext multi-tenant mode).
* **Переменные окружения не применяются:** .env файл должен лежать в одной директории с `docker-compose.yml`. Если при запуске переменные не подхватываются, убедитесь, что имя файла именно `.env` и в Compose-файле указано `env_file: .env`. Также проверьте формат – **без кавычек** вокруг значений (кроме случаев, когда есть пробелы) и без лишних пробелов вокруг `=`.
* **Проблемы с кодировкой и концом строк (.env на Windows):** Если вы редактировали .env в Windows, возможно, файл содержит CRLF окончания строк, что может привести к ошибкам (например, пароли считываются с лишним символом `\r`). Решение – открыть .env в продвинутом редакторе и переключить line endings на LF, либо запустить `dos2unix .env`. Аналогичная проблема может возникнуть с исполняемыми скриптами (они могут не запускаться в контейнере из-за `\r`).
* **Права доступа и монтирование файлов:** Если вы в dev-режиме монтируете директории, помните, что внутри контейнера пользователя `frappe` (uid 1000) должен иметь права на эти файлы. Иногда примонтированные от root папки могут мешать. Решение – менять владельца на хосте или внутри контейнера (`chown -R 1000:1000 /path`).
* **Остановка и запуск заново:** При переключении веток или обновлении образов могут остаться старые volume с данными. Если нужно полностью сбросить окружение, используйте `docker compose down --volumes` (удалит и контейнеры, и связанные volumes). **Внимание:** в продакшене это приведёт к потере данных, используйте только если уверены.
* **Ошибка при миграции Custom DocType:** Если миграция останавливается с сообщением о существующих Custom Field или DocType, возможно, у вас конфликт версий. Решение – попробовать удалить проблемные записи вручную через DB или `bench --site <site> reinstall` (но последнее удалит все данные, используйте только на тесте).
* **Проблемы с CRON и планировщиком:** Если задания (Scheduled Jobs) не выполняются, проверьте, запущен ли `scheduler`. В dev-режиме `bench start` его запускает, но если вы вручную запускали без него, то отложенные задачи не выполняются. Можно проверить статус: `bench --site <site> scheduler-enable` / `scheduler-disable` и `bench doctor`.
* **Локализация (русский язык):** Если интерфейс ERPNext требуется на русском, убедитесь, что установлены переводы: выполните `bench setup translate ru`. Кастомные DocType/поля можно перевести через Custom Translation или добавить `.csv` файлы переводов в приложение.

Если проблема не попадает ни под одно описание – изучите логи (`sites/<site>/logs` для ERPNext, `~/frappe-bench/logs` для bench) и обратитесь к сообществу ERPNext/Frappe. Так как Ferum Customizations – кастомный проект, сначала попытайтесь воспроизвести проблему на чистом ERPNext, чтобы понять, в базовой платформе дело или в кастомном коде.

## 8. Дополнительные сведения и лучшие практики

Ниже рассмотрены дополнительные аспекты, касающиеся CI/CD, управления кодом и качеством, структуры проекта, безопасности и мониторинга. Эти практики основаны на архитектуре и требованиях проекта Ferum Customizations.

### 8.1. CI/CD через GitHub Actions

Проект использует интеграцию с **GitHub Actions** для обеспечения качества кода и автоматического деплоя. В репозитории настроены workflows, которые запускаются при создании Pull Request и при пуше в определённые ветки:

* **Линтеры и статический анализ:** При каждом pull request запускается job (см. `.github/workflows/linter.yml`), который выполняет `pre-commit` проверки – автоформатирование Black, линтинг Ruff, анализ типов mypy, а также проверка шаблонов безопасности (Semgrep). Это гарантирует, что код соответствует стандартам перед слиянием.
* **Тесты и деплой:** Основной CI (`.github/workflows/ci.yml`) собирает окружение (bench, нужные сервисы), разворачивает тестовый сайт и прогоняет все юнит-тесты проекта. Если тесты проходят и код пушится в ветку `develop` (условно – staging), workflow автоматически деплоит изменения на сервер. Обычно деплой происходит посредством SSH: runner подключается к удалённому серверу и выполняет обновление (например, останавливает контейнеры, тянет новый образ/код, запускает миграции). В некоторых случаях настроен CD и на production (при пуше тега или в master/main ветку – см. конкретную конфигурацию вашего репо).

Для разработчика это означает, что при работе с кодом:

* Надо писать тесты для нового функционала. Проект, вероятно, использует `pytest` для тестирования (см. папку `ferum_customs/tests`). Тесты запускаются в CI, и также их можно запускать локально: `pytest` в директории bench (есть фикстуры, создающие временный сайт).
* Следует соблюдать стиль кода. Настроены pre-commit hooks, потому убедитесь, что запустили `pre-commit install` локально один раз. Тогда при каждом коммите будут автоматически исправляться форматирование и выявляться ошибки. Можно вручную прогнать все проверки: `pre-commit run --all-files`.
* При слиянии изменений убедитесь, что версия приложения обновлена (в setup.py или манифесте) при необходимости, чтобы деплой зафиксировал новую версию.

CI/CD экономит время на ручных деплоях и уменьшает вероятность пропустить какую-то проблему – интеграция и тесты проверяют приложение на корректность и готовность к релизу.

### 8.2. Экспорт фикстур (Custom Fields, Roles, Workflows)

ERPNext позволяет создавать *кастомизации* (Custom Field, Custom Script, настройки ролей, Workflows) через пользовательский интерфейс. Однако, чтобы эти изменения переносились между инстансами (например, с dev на production), их нужно экспортировать в код. В Ferum Customizations это реализовано через механизм **fixtures** Frappe.

В файле `hooks.py` приложения перечислены фикстуры, которые должны экспортироваться при выполнении команды `bench export-fixtures`. Например:

```python
fixtures = [
    "custom_fields",
    "custom_docperm",
    {
        "dt": "Role",
        "filters": [["name", "in", ["Проектный менеджер", "Инженер", "Заказчик"]]]
    },
    {"dt": "Workflow", "filters": [["name", "in", ["Service Request Workflow"]]]},
    "customer",
    "service_project",
    ...
]
```

Это означает:

* Все созданные **Custom Field** (кастомные поля) будут сохранены в JSON-файл `fixtures/custom_field.json`.
* Все **Custom DocPerm** (настройки разрешений) – в `fixtures/custom_docperm.json`.
* Роли с именами "Проектный менеджер", "Инженер", "Заказчик" – экспортируются (видимо, это кастомные роли). Они сохранятся в файл `fixtures/role.json` с фильтрацией по именам.
* Workflow с именем "Service Request Workflow" – сохраняется в `fixtures/workflow.json`.
* Также указаны DocType `customer`, `service_project`, `service_object` и т.д. – вероятно, это кастомные DocType приложения, и экспортируя их таким образом, разработчики фиксируют их состояние/настройки (хотя DocType обычно и так хранится в коде, возможно, речь о DocType созданных через UI или о стандартных DocType, которые были изменены).

Когда вы вносите изменения через UI (например, добавили новое поле в форму или изменили Workflow), выполните:

```bash
bench export-fixtures
```

Это обновит JSON-файлы в папке вашего приложения (или создаст её, если нет). Не забудьте закоммитить эти изменения в репозиторий. При установке приложения на другом сайте все указанные объекты будут автоматически созданы/обновлены.

Кроме фикстур, **патчи** (patches) используются для миграции данных. В Ferum Customizations есть файл `ferum_customs/patches.txt` и, возможно, скрипты в `ferum_customs/patches/`. Если вы меняете существующую схему через код, добавляйте патч, чтобы преобразовать данные (Frappe вызовет его при `bench migrate`). Если же изменение через Custom Field – достаточно фикстуры.

Использование фикстур и патчей обеспечивает воспроизводимость настроек. Документация Frappe рекомендует хранить критичные бизнес-правила (Roles, Workflows) в коде, чтобы при деплое не нужно было настраивать вручную. Ferum Customizations следует этому принципу.

### 8.3. Контроль качества кода: pre-commit, типизация

Как упоминалось, проект строго следует стандартам кода. Внедрены следующие инструменты:

* **pre-commit** – framework для запуска линтеров и форматтеров при коммите. В `.pre-commit-config.yaml` перечислены хуки:

  * **Black** – автоформатирование Python-кода под PEP8.
  * **Ruff** – быстрый линтер, ловящий ошибки и стилистические проблемы.
  * **Mypy** – проверка статической типизации.
  * *Также*, возможно, Flake8, isort и др., но Ruff часто заменяет их.
    Перед коммитом выполните:

  ```bash
  pre-commit run --all-files
  ```

  Это запустит форматирование и проверки для всех файлов проекта. Исправьте обнаруженные замечания, если они есть. Многие будут исправлены автоматически (Black, isort). Если mypy выдаёт ошибки типов, проверьте аннотации и соответствие типам (в коде Ferum Customizations ожидается, что все функции аннотированы, а mypy – в режиме strict).
* **Тестирование (pytest):** Пишите юнит-тесты для новой логики. Проект включает тесты (директория `ferum_customs/tests`). Для их запуска убедитесь, что у вас есть тестовое окружение (можно использовать `bench --site test_site run-tests` или настроить pytest.ini с фикстурами). В Ferum Customizations тестовая среда настраивается автоматически через фикстуры `conftest.py` – там создаётся временный сайт и устанавливается приложение перед тестами. Запуск тестов:

  ```bash
  pytest
  ```

  (Лучше в CI или контейнере, чтобы совпадала версия БД и окружения.)
* **Код-ревью:** При работе в команде, используйте пулл-реквесты для внесения изменений. Один из файлов репозитория `AGENTS.md` указывает, что нужно *“поддерживать высокое качество кода, следовать архитектуре Frappe и обеспечивать полное покрытие тестами”*. То есть, не вносите хаотичных изменений, соблюдайте структуру (о ней далее) и пишите тесты на новый функционал.

Кроме того, **статический анализ безопасности** (Semgrep) может быть настроен. Он проверяет на распространённые уязвимости (например, использование eval, SQL-инъекции). Исправляйте по его рекомендациям.

Подводя итог: автоматизированные инструменты очень помогают, но финальное качество зависит от вас. Следуйте принципам чистого кода, документируйте сложные участки (docstring’ами), и проект останется поддерживаемым.

### 8.4. Структура проекта (Bench, App, Doctype, API, Print Format)

Проект Ferum Customizations разделён на несколько логических частей:

* **Bench-папка**: если вы разворачиваете проект как Bench, у вас будет структура `frappe-bench/` с подпапками `apps/`, `sites/`, `logs/` и т.п. В Docker-варианте это всё внутри контейнера/volume. Эта структура задаётся самим Frappe Bench. В режиме Docker Compose вы взаимодействуете в основном через команды Docker/bench, а структура на хосте не видна.

* **Кастомное приложение (`ferum_customs`)**: это Python-пакет внутри `apps/` (или папка в репозитории). В нём содержится весь код, специфичный для бизнес-логики компании. Основные файлы/директории внутри приложения:

  * `hooks.py` – регистрирует настройки приложения: включаемые JS/CSS, doctype- и scheduler-ивенты, fixtures, overrides и т.д. Мы видели пример, что там перечислены doc\_events, fixtures и т.п..
  * `ferum_customs/doctype/` – здесь каждое подкаталог – определение DocType. Например, `ferum_customs/doctype/service_request/` содержал бы `service_request.json` (описание DocType), `service_request.py` (серверные скрипты, если есть), `service_request.js` (клиентский скрипт для формы), а также файлы, как `service_request_dashboard.py` (для Dashboard), печатные формы или отчёты, если они привязаны к этому DocType.
  * `ferum_customs/api.py` – как правило, в Frappe можно определять **whitelisted** методы (декоратор `@frappe.whitelist`) в файле `api.py` для быстрого доступа из клиента. Тут можно разместить функции, которые будут вызваны с фронта через `frappe.call`. В проекте указано, что *“публичные серверные методы, доступные с клиента, размещайте в ferum\_customs/api.py”*.
  * `ferum_customs/custom_logic/` (если есть) – упоминается, что бизнес-логика и обработчики событий выносятся в `custom_logic/` с подключением их через hooks. То есть, могли сделать структурно: хранить код, реагирующий на DocType events, отдельно для чистоты (например, `custom_logic/service_request.py` и в `hooks.py` прописать doc\_events для Service Request, ссылающиеся на функции оттуда).
  * `ferum_customs/patches/` – патчи для миграции. Если менялись существующие DocType (поле добавилось, нужно перенести данные), сюда добавляют скрипт + вписывают его в `patches.txt`.
  * `ferum_customs/print_format/` – кастомные печатные формы, если создавались, сохраняются как JSON с HTML шаблоном. Например, `ferum_customs/print_format/ServiceReport/ServiceReport.json` – для печатной формы акта. Если вы создаёте Print Format через веб-интерфейс, его тоже можно экспортировать (через Fixtures или вручную сохранить .json).
  * `ferum_customs/config/` – обычно содержит `desktop.py`, `notifications.py` и прочие конфиги (формирование рабочего стола, уведомления системы). В hooks мы видим ссылку на `get_notification_config = "ferum_customs.notifications.notifications.get_notification_config"` – значит, файл `notifications.py` определяет какие уведомления показывать пользователям.
  * `ferum_customs/tests/` – тесты приложения (pytest). Там, скорее всего, есть фикстура для поднятия тестового сайта (см. `conftest.py`) и тесты отдельных модулей.

* **Backend (FastAPI) приложение**: Вне Frappe, в папке `backend/`, располагается отдельное приложение на FastAPI. Зачем оно нужно? Согласно архитектуре, там реализован, например, REST API для внешнего мира, интеграции с ботами, Google API и т.п., которые не удобно или не хочется делать средствами Frappe. Структура `backend`:

  * `main.py` (возможно) или инициализация FastAPI-приложения.
  * `routers/` – набор маршрутов (например, `routers/metrics.py` для Prometheus метрик, `routers/some_module.py`).
  * `auth.py` – всё, что связано с JWT, OAuth2 схемами, получение текущего пользователя. Мы видели, что там описаны функции проверки токена и получения ролей через FrappeClient (REST API ERPNext).
  * `bot/` – логика Telegram/WhatsApp ботов. Есть `telegram_bot.py`, который можно запускать отдельно.
  * `config.py` – вероятно, pydantic-модель настроек (например, SECRET\_KEY, ERP\_API\_URL хранятся там).
  * `requirements.txt` – зависимости (FastAPI, pydantic, jose для JWT, etc.).

Backend-приложение работает параллельно с ERPNext. Взаимодействие: через REST API Frappe (с использованием FrappeClient) или прямые запросы, а также посредством JWT аутентификации пользователей (в FastAPI проверяются роли, полученные из ERPNext). **Важно:** В production оно должно быть защищено, см. раздел безопасность.

* **Прочие компоненты:**

  * **Печатные формы:** кроме JSON, могут быть кастомные печатные формы, созданные через интерфейс ERPNext, привязанные к DocType (например, акт выполненных работ). Их можно экспортировать либо через Fixtures (DocType `Print Format`), либо сохранить как отдельные шаблоны и включить в код.
  * **Клиентский код (JS):** Если интерфейс кастомизируется на уровне форм, файлы `.js` внутри каждого DocType папки управляют поведением форм (они подключаются автоматически, если `is_custom` = 0). Также может быть общий JS (например, в `public/js/`), подключаемый через hooks (property `app_include_js`).
  * **API интеграции:** Документ `docs/integrations.md` (упоминался в поиске) может описывать, как настроены внешние интеграции (например, Google Sheets sync, Drive). Частично это отражено и в `Development Notes` – где сказано, что для реальной работы интеграций нужно установить дополнительные Python-библиотеки (`gspread`, `google-api-python-client`) и настроить credentials. Обратите внимание: эти части кода в `ferum_customs` скорее заглушки (placeholder), которые нужно доделать перед production (в DevNotes отмечено, что методы sync\_to\_google\_sheets и CustomAttachment.before\_insert имеют заглушки).

При добавлении нового функционала сохраняйте структуру. Например, новую серверную логику – в соответствующий DocType или под `custom_logic/` с вызовом из hooks; REST API – в FastAPI backend (если это для внешних клиентов); обработку фоновых задач – либо Scheduler Event (hooks.py: scheduler\_events), либо как отдельный service.

Поддержание чёткого разделения позволит другим разработчикам (или AI агентам – судя по AGENTS.md) быстро понимать, куда поместить новый код и где искать существующий.

### 8.5. Рекомендации по безопасности

Безопасность системы включает несколько уровней:

* **Аутентификация и доступ:** Используется ERPNext для управления пользователями и ролями, а также дополнительная JWT-аутентификация для внешнего API. Рекомендуется включить **двухфакторную аутентификацию (2FA)** для всех привилегированных пользователей (Администратор, руководители) – ERPNext поддерживает 2FA из коробки (TOTP приложение или email код). На стороне FastAPI реализован OAuth2 Password Flow с выдачей JWT-токена, а также проверка ролей при обращениях к API. Убедитесь, что секретный ключ JWT (`SECRET_KEY`) достаточно сложный и хранится безопасно, а токены имеют срок жизни (например, 30 минут). Не раздавайте JWT без необходимости, а для внутренних сервисов используйте `FASTAPI_INTERNAL_JWT_TOKEN` (как дополнительный секрет).
* **Разграничение прав:** Настройте **Role-Based Access Control** правильно – роли и разрешения в системе должны соответствовать описанным бизнес-релям (Администратор, Проектный менеджер, Инженер, Клиент и т.д.). Каждый DocType должен иметь ограничения по ролям (см. `permission_matrix` в docs). Также, возможно, реализованы **permission query** скрипты – например, чтобы Клиент видел только свои документы. Проверьте, что чувствительные DocType (Invoices, Payroll) закрыты от неподходящих ролей. Эти правила уже заложены в фикстуры ролей и разрешений, убедитесь, что они применены.
* **Сетевые соединения (HTTPS):** Всё внешнее взаимодействие должно идти по HTTPS. В продакшене обязательно настроить TLS-сертификаты на веб-сервере (Nginx). В конфигурации Nginx установите современные параметры безопасности (HSTS header, отключение старых протоколов TLS, etc.). Если есть доступ к системе извне (например, API для клиента), без HTTPS токены и данные могут быть перехвачены.
* **Ограничение по скорости (Rate Limiting):** Чтобы предотвратить brute-force и DoS-атаки на API, стоит внедрить ограничение запросов. В FastAPI это можно сделать с помощью библиотек типа **SlowAPI** (интеграция с Starlette) – упоминание о ней есть в спецификации. Настройте, например, не более X запросов в минуту на ключ/IP для публичных API endpoints. Для ERPNext (если открыта клиентская часть, например портал) – Nginx модуль limit\_req или сторонний WAF может пригодиться.
* **Безопасность данных:** ERPNext по умолчанию хэширует пароли, но убедитесь, что **конфиденциальные данные** (например, персональные данные сотрудников, клиентов) защищены. Frappe позволяет отмечать поля как "Protected" (шифрование в БД) – используйте это для критичных полей (например, паспортные данные, если такие есть). В спецификации упоминается, что рассматривается шифрование определённых полей с помощью AES. Также, все бэкапы должны храниться **в шифрованном виде** или в защищённом месте (restic шифрует по умолчанию, а Google Drive папка ограничена доступом).
* **Журналирование и аудит:** ERPNext ведёт аудит Trail (версии документов) – не отключайте его на важных DocType. Для входов включите Track Login (System Settings). Логи действий администраторов стоит периодически просматривать. В Ferum Customizations, возможно, ведётся отдельный журнал (например, в БД или файле) для критичных операций.
* **Сторонние интеграции:** При интеграции с внешними API (Google, Telegram) используйте ограниченные сервисные аккаунты. Ключи и токены храните только в `site_config.json` или `.env` (которые не в репозитории). Например, Google API ключ JSON положите в `private/keys` и не выдавайте никому, Telegram токен – только на сервере.

Руководствуйтесь принципом **минимально необходимых привилегий**: пользователям давайте только те роли, которые нужны; сервисным аккаунтам – только нужные scopes API; контейнеры Docker не запускайте с `--privileged` (и по возможности используйте непривилегированного пользователя внутри, что уже сделано – пользователь frappe с uid 1000). Безопасность – не разовая задача, а постоянный процесс, убедитесь, что она “продумана в каждую часть системы”.

### 8.6. Мониторинг и логирование

Для стабильной работы в продакшене настройте мониторинг системы и сбор ошибок:

* **Показатели и метрики (Prometheus):** Проект предусматривает интеграцию с **Prometheus** для сбора метрик производительности. В FastAPI-бэкэнде уже реализован эндпоинт `/metrics` с метриками запросов (количество, ошибки, время обработки). Разверните сервер Prometheus и укажите ему target – ваш сервер (Nginx прокси) по адресу `http://<your-domain>/api/v1/metrics` или напрямую сервис FastAPI. Так вы сможете мониторить загрузку системы: скорость обработки заявок, число ошибок 5xx и т.д. При необходимости, добавьте дополнительные метрики в код (например, количество открытых ServiceRequest, метрики по ботам).
* **Логирование и ошибки (Sentry):** Рекомендуется подключить сервис отслеживания ошибок **Sentry**. Для этого получите DSN проекта в Sentry, установите `sentry-sdk` в FastAPI и Frappe. В FastAPI интегрировать просто:

  ```python
  import sentry_sdk
  from sentry_sdk.integrations.fastapi import FastApiIntegration
  sentry_sdk.init(dsn="<YOUR_DSN>", integrations=[FastApiIntegration()])
  ```

  – это будет отправлять все необработанные исключения FastAPI в Sentry. Для ERPNext можно использовать `sentry-sdk` с интеграцией для logging (или отдельный `frappe_sentry` плагин). По крайней мере, можно ловить ошибки из `frappe.log_error` через кастомный логгер. Также имеет смысл отправлять в Sentry сообщения об особых ситуациях, например, если бот не смог разослать сообщение или Google API вернул ошибку.
* **Мониторинг производительности сервера:** Отслеживайте нагрузку на CPU/RAM/IO. Если используете Docker, можно развёрнуть cAdvisor + Grafana для метрик контейнеров. Prometheus тоже может это собирать. Контролируйте, чтобы PostgreSQL не потреблял всю память (настройте параметры shared buffers и пр. под доступные ресурсы), а воркеры ERPNext не заваливайся из-за нехватки RAM.
* **Алерты:** Настройте оповещения на важные метрики: например, через Alertmanager (для Prometheus) – если сайт недоступен, или количество ошибок резко выросло, или размер бэкапа не обновлялся (что может значить сбой резервного копирования). В Sentry тоже настройте алерты (по email/Slack) на новые ошибки уровня ERROR.
* **Логи аудита:** Как часть мониторинга, собирайте логи Nginx (доступов и ошибок) – можно отправлять их на централизованный лог-сервер или просматривать раз в неделю на предмет подозрительной активности. Также, если использованы **Telegram-уведомления** для важных событий (возможно, админ боту настроено уведомлять о новых заявках, просроченных задачах и т.п.), следите, чтобы бот был всегда онлайн – это тоже часть “мониторинга” бизнес-процессов.

Наконец, документируйте инциденты и ошибки. Если, например, произошёл сбой и вы его устранили, добавьте в документацию (возможно, в репозитории есть `staging_notes.md` или `PROGRESS.md`) заметки о проблеме и решении. Это поможет в будущем и повысит надёжность эксплуатации.

---

Следуя данной инструкции, вы сможете успешно установить Ferum Customizations, настроить окружение для разработки, развернуть приложение в продакшене и поддерживать его бесперебойную работу. Все шаги выверены на основе архитектуры и практического опыта внедрения системы. Уделяйте внимание деталям на каждом этапе – от правильного заполнения `.env` до мониторинга после деплоя – и система оправдает ожидания, автоматизируя ваши бизнес-процессы в сфере сервисного обслуживания. Удачной работы!
